<!doctype html>
<html lang="he">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>×¢×’×œ×” + ×’×œ×’×œ×ª + ××©×§×•×œ×ª + ×§×¤×™×¥ (×“×™× ××™×§×”/×§×™× ××˜×™×§×”)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: Arial, sans-serif; direction: rtl; background:#0b0f14; color:#e8edf2; }
    header { padding:12px 14px; background:#0d131b; border-bottom:1px solid #1c2633; position:sticky; top:0; }
    h1 { margin:0; font-size:18px; }
    .wrap { display:flex; gap:12px; padding:12px; }
    .panel { width:360px; min-width:320px; background:#0d131b; border:1px solid #1c2633; border-radius:12px; padding:12px; }
    canvas { flex:1; background: radial-gradient(1000px 600px at 30% 25%, #0f1825 0%, #070a0e 60%, #050608 100%);
             border:1px solid #1c2633; border-radius:12px; }
    .row { display:flex; align-items:center; gap:10px; margin:8px 0; }
    .row label { flex:1; font-size:13px; opacity:.9; }
    .row input[type="range"] { flex:1.1; }
    .row .val { width:74px; text-align:left; font-variant-numeric: tabular-nums; opacity:.9; }
    button { cursor:pointer; border:1px solid #263449; background:#101a26; color:#e8edf2; padding:8px 10px; border-radius:10px; }
    button:hover { background:#122033; }
    .btns { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .hint { font-size:12px; opacity:.82; line-height:1.35; margin-top:10px; }
    .box { margin-top:10px; padding:10px; border:1px solid #1c2633; border-radius:10px; background:#0a1017; font-size:12px; }
    .pill { display:inline-block; padding:2px 8px; border:1px solid #263449; border-radius:999px; font-size:12px; opacity:.9; }
  </style>
</head>
<body>
<header>
  <h1>ğŸ§µğŸŒ€ ×¢×’×œ×” ×¢×œ ××¡×™×œ×” + ×—×•×˜/×’×œ×’×œ×ª + ××©×§×•×œ×ª + ×§×¤×™×¥</h1>
</header>

<div class="wrap">
  <div class="panel">
    <div class="row"><span class="pill">××” ×§×•×¨×” ×¤×”?</span></div>
    <div class="hint">
      ×”×¢×’×œ×” (mâ‚) ××—×•×‘×¨×ª ×œ×§×¤×™×¥ ×œ×§×™×¨. ×”×¢×’×œ×” ××—×•×‘×¨×ª ×‘×—×•×˜ ×œ×’×œ×’×œ×ª ×•××©× ×œ××©×§×•×œ×ª ×ª×œ×•×™×” (mâ‚‚).
      ×× ×”×¢×’×œ×” ×–×–×” ×™××™× ×” ×‘Ö¾x â†’ ×”××©×§×•×œ×ª ×™×•×¨×“×ª ×‘Ö¾x (×§×©×¨ ×§×™× ××˜×™ ×©×œ ×—×•×˜ ××™×“××œ×™).
    </div>

    <hr style="border:none;border-top:1px solid #1c2633;margin:12px 0;">

    <div class="row">
      <label>××¡×” ×¢×’×œ×” mâ‚</label>
      <input id="m1" type="range" min="0.5" max="10" value="3" step="0.1">
      <div class="val" id="m1Val"></div>
    </div>

    <div class="row">
      <label>××¡×” ×ª×œ×•×™×” mâ‚‚</label>
      <input id="m2" type="range" min="0.2" max="8" value="2.2" step="0.1">
      <div class="val" id="m2Val"></div>
    </div>

    <div class="row">
      <label>×§×‘×•×¢ ×§×¤×™×¥ k</label>
      <input id="k" type="range" min="10" max="900" value="220" step="1">
      <div class="val" id="kVal"></div>
    </div>

    <div class="row">
      <label>××™×§×•× ×× ×•×—×” xâ‚€</label>
      <input id="x0" type="range" min="-200" max="200" value="0" step="1">
      <div class="val" id="x0Val"></div>
    </div>

    <div class="row">
      <label>×©×™×›×•×š/×—×™×›×•×š c</label>
      <input id="c" type="range" min="0" max="12" value="1.2" step="0.1">
      <div class="val" id="cVal"></div>
    </div>

    <div class="row">
      <label>×›×‘×™×“×” ××—×™×“×” g</label>
      <input id="g" type="range" min="0" max="1600" value="900" step="10">
      <div class="val" id="gVal"></div>
    </div>

    <hr style="border:none;border-top:1px solid #1c2633;margin:12px 0;">

    <div class="btns">
      <button id="playPause">â¸ï¸ ×¢×¦×•×¨</button>
      <button id="reset">â†©ï¸ ××™×¤×•×¡</button>
      <button id="zeroV">v=0</button>
    </div>

    <div class="box" id="readout"></div>

    <div class="hint">
      <b>×©×œ×™×˜×”:</b><br>
      â€¢ ×’×¨×•×¨ ××ª ×”×¢×’×œ×” ×¢× ×”×¢×›×‘×¨ ×›×“×™ ×œ×§×‘×•×¢ ××¦×‘ ×”×ª×—×œ×ª×™ (×•××– ×©×—×¨×¨).<br>
      â€¢ ×©×™× ×œ×‘: ×›××Ÿ ××™×Ÿ â€œ××©×™×›×” ×‘×™×Ÿ ×’×•×¤×™×â€ â€” ×¨×§ ×›×‘×™×“×” ××—×™×“×” ×¢×œ ×”××©×§×•×œ×ª ×•×§×¤×™×¥.
    </div>
  </div>

  <canvas id="cvs" width="1100" height="720"></canvas>
</div>

<script>
(() => {
  const canvas = document.getElementById('cvs');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  // UI
  const ui = {
    m1: document.getElementById('m1'),
    m2: document.getElementById('m2'),
    k: document.getElementById('k'),
    x0: document.getElementById('x0'),
    c: document.getElementById('c'),
    g: document.getElementById('g'),
    m1Val: document.getElementById('m1Val'),
    m2Val: document.getElementById('m2Val'),
    kVal: document.getElementById('kVal'),
    x0Val: document.getElementById('x0Val'),
    cVal: document.getElementById('cVal'),
    gVal: document.getElementById('gVal'),
    readout: document.getElementById('readout')
  };
  function refresh(){
    ui.m1Val.textContent = (+ui.m1.value).toFixed(1);
    ui.m2Val.textContent = (+ui.m2.value).toFixed(1);
    ui.kVal.textContent  = (+ui.k.value).toFixed(0);
    ui.x0Val.textContent = (+ui.x0.value).toFixed(0);
    ui.cVal.textContent  = (+ui.c.value).toFixed(1);
    ui.gVal.textContent  = (+ui.g.value).toFixed(0);
  }
  ['input','change'].forEach(ev=>{
    [ui.m1,ui.m2,ui.k,ui.x0,ui.c,ui.g].forEach(el=>el.addEventListener(ev, refresh));
  });
  refresh();

  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  // Geometry (screen coordinates)
  const trackY = H*0.55;
  const leftWallX = W*0.12;
  const pulleyX = W*0.78;
  const pulleyY = H*0.35;

  const cart = { w: 140, h: 70 };
  const massBox = { w: 64, h: 64 };

  // State (1DOF) : x is cart displacement along track relative to an origin.
  // Constraint: hanging mass y depends on x (rope length constant).
  let x = 0;      // px
  let v = 0;      // px/s
  let a = 0;      // px/s^2

  // Choose origin so cart starts centered-ish
  const xMin = -260, xMax = 260;

  // Base positions
  const cartBaseX = W*0.42;

  // Rope: we don't need explicit length; we enforce y = y0 + x (sign) by construction.
  // If cart moves right (+x), rope segment to pulley gets longer, so hanging mass moves DOWN (+y).
  const yHangTop = pulleyY + 30;
  const y0 = 0; // reference offset for hanging position
  // We'll compute hanging y from x.

  // Interaction
  const mouse = {x:0,y:0, down:false, dragging:false};
  canvas.addEventListener('mousemove', (e)=>{
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (e.clientY - r.top)  * (canvas.height / r.height);
  });
  canvas.addEventListener('mousedown', ()=>{
    mouse.down = true;
    const cartX = cartBaseX + x;
    const cartY = trackY - cart.h;
    if (mouse.x >= cartX-cart.w/2 && mouse.x <= cartX+cart.w/2 &&
        mouse.y >= cartY && mouse.y <= cartY+cart.h){
      mouse.dragging = true;
    }
  });
  window.addEventListener('mouseup', ()=>{
    mouse.down = false;
    mouse.dragging = false;
  });

  // Controls
  let running = true;
  document.getElementById('playPause').addEventListener('click', (e)=>{
    running = !running;
    e.target.textContent = running ? 'â¸ï¸ ×¢×¦×•×¨' : 'â–¶ï¸ ×”×¤×¢×œ';
  });
  document.getElementById('zeroV').addEventListener('click', ()=>{
    v = 0;
  });
  document.getElementById('reset').addEventListener('click', ()=>{
    x = 0;
    v = 0;
  });

  // Dynamics:
  // (m1+m2) a = m2*g - k(x-x0) - c*v
  function step(dt){
    const m1 = +ui.m1.value;
    const m2 = +ui.m2.value;
    const k  = +ui.k.value;
    const x0 = +ui.x0.value;
    const c  = +ui.c.value;
    const g  = +ui.g.value;

    if (mouse.dragging){
      // map mouse.x to x
      const targetX = clamp(mouse.x - cartBaseX, xMin, xMax);
      x = targetX;
      v = 0; // simple: no "throw" velocity
      a = 0;
      return;
    }

    const Fg = m2 * g;           // pulls system (down => +x)
    const Fs = k * (x - x0);     // spring resists if x > x0
    const Fd = c * v;            // damping
    a = (Fg - Fs - Fd) / (m1 + m2);

    // semi-implicit Euler (stable enough here)
    v += a * dt;
    x += v * dt;

    // bounds to keep it on screen (acts like end stops)
    if (x < xMin){ x = xMin; v *= -0.2; }
    if (x > xMax){ x = xMax; v *= -0.2; }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    // little stars / texture
    ctx.save();
    ctx.globalAlpha = 0.25;
    for (let i=0;i<120;i++){
      ctx.fillRect((i*97)%W, (i*211)%H, 1, 1);
    }
    ctx.restore();

    // Track
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(leftWallX, trackY);
    ctx.lineTo(pulleyX-30, trackY);
    ctx.stroke();

    // Wall (spring anchor)
    ctx.fillStyle = 'rgba(180,200,220,0.25)';
    ctx.fillRect(leftWallX-12, trackY-120, 12, 140);

    // Pulley
    ctx.beginPath();
    ctx.arc(pulleyX, pulleyY, 26, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(160,180,200,0.18)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Positions
    const cartX = cartBaseX + x;
    const cartY = trackY - cart.h;

    const hangX = pulleyX + 0;
    const hangY = yHangTop + (x - xMin) * 0.85; // visual scale (still monotonic with x)

    // Rope (2 segments: cart->pulley and pulley->mass)
    ctx.strokeStyle = 'rgba(230,230,230,0.75)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(cartX, cartY+10);
    ctx.lineTo(pulleyX, pulleyY+4);
    ctx.lineTo(hangX, hangY);
    ctx.stroke();

    // Spring (wall -> cart)
    drawSpring(leftWallX, trackY-45, cartX - cart.w/2, trackY-45, 14, 10);

    // Cart
    ctx.save();
    ctx.translate(cartX, cartY);
    roundRect(-cart.w/2, 0, cart.w, cart.h, 14, 'rgba(255,190,90,0.90)', 'rgba(255,255,255,0.22)');
    // wheels
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath(); ctx.arc(-45, cart.h+10, 14, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( 45, cart.h+10, 14, 0, Math.PI*2); ctx.fill();
    ctx.restore();

    // Hanging mass
    ctx.save();
    roundRect(hangX - massBox.w/2, hangY, massBox.w, massBox.h, 12, 'rgba(120,200,255,0.88)', 'rgba(255,255,255,0.22)');
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('mâ‚‚', hangX, hangY + 38);
    ctx.restore();

    // HUD (numbers)
    ui.readout.innerHTML =
      `<b>××¦×‘ ×§×™× ××˜×™</b><br>` +
      `x = ${x.toFixed(1)} px &nbsp; | &nbsp; v = ${v.toFixed(1)} px/s &nbsp; | &nbsp; a = ${a.toFixed(1)} px/sÂ²<br><br>` +
      `<b>×“×™× ××™×§×” (×›×•×—×•×ª ×¢×œ ×”××¢×¨×›×ª)</b><br>` +
      `Fg = mâ‚‚Â·g &nbsp; | &nbsp; Fs = k(xâˆ’xâ‚€) &nbsp; | &nbsp; Fd = cÂ·v<br>` +
      `<span style="opacity:.85">××©×•×•××”: (mâ‚+mâ‚‚)a = mâ‚‚g âˆ’ k(xâˆ’xâ‚€) âˆ’ c v</span>`;
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    ctx.beginPath();
    const rr = Math.min(r, w/2, h/2);
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    ctx.fillStyle = fill; ctx.fill();
    ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke();
  }

  function drawSpring(x1,y1,x2,y2,coils,amp){
    const dx = x2-x1, dy=y2-y1;
    const len = Math.max(1e-6, Math.hypot(dx,dy));
    const nx = dx/len, ny = dy/len;
    const px = -ny, py = nx;

    ctx.beginPath();
    ctx.moveTo(x1,y1);

    const start = 10, end = 10;
    const usable = Math.max(1, len - start - end);
    for (let i=0; i<=coils; i++){
      const t = i / coils;
      const along = start + t*usable;
      const zig = (i%2===0 ? -1 : 1) * amp;
      const sx = x1 + nx*along + px*zig;
      const sy = y1 + ny*along + py*zig;
      ctx.lineTo(sx,sy);
    }
    ctx.lineTo(x2,y2);
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = 'rgba(180,220,255,0.75)';
    ctx.stroke();
  }

  // Loop
  let last = performance.now();
  function frame(t){
    const dtRaw = (t-last)/1000;
    last = t;
    const dt = clamp(dtRaw, 0, 0.03);

    if (running){
      const sub = 4;
      const h = dt / sub;
      for (let i=0;i<sub;i++) step(h);
    }

    draw();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
